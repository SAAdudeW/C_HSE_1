#define _CRT_SECURE_NO_WARNINGS

#include <locale.h>
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>

// + функция формирования исходного файла
// + функция вывода результата работы программы
// + функция задания
/* + Дан текстовый файл f
+ Пользователь вводит строку s
+ Найти все строки файла f, содержащие в себе s 
+ Записать в g соответствующий строки */

// + исключительные случаи
/* - пустая строка Если перед пустой строкой строка максимального размера, то вставляемый символ новой строки не влазит
+ полная строка
+ все подходят
+ ни одна не подходит
+ некоторые подходят
*/

// - проверка
// + пустые строки в консоли появляются, поскольку fgets добавляет символ новой строки после считывания в записываемую переменную
// - доплнительный feof
// - новый fgets с прошлого места начинает и переходит на новую строку

/* 7 qwerty

qwertyuiopasdfghjklzxcvbnm1234567890asdfgh

sdgqwertyregtrb23
e3qwerfqwerty
grehyrth
qwerty34tgerqwerty45th
34vqwerty43frg
*/

void def(char* ADDRESSf) { // функция формирования исходного файла

	char str[50]; // массив для строк
	int i = 0, k;
	
	printf(" Сколько строк введете в файл? "); scanf("%d", &k); // сколько строк в файле?

	FILE* f = fopen(ADDRESSf, "w"); // открытие потока на запись в f.txt

	getchar(); printf("\n");
	if (f != NULL) { // если поток открылся успешно
		for (i = 0; i < k; i++) {
			printf(" Введи %d-ую строку: ", i + 1);
			gets_s(str, 50); // ввод строки
			fputs(str, f); fputs("\n", f); // запись введенной строки в файл c переходом на новую строку
		}
	}
	else printf("Не удалось открыть файл");
	
	fclose(f); // закрытие потока
}

void work(char* ADDRESSf, char* ADDRESSg, char* s) { // функция задания

	char STR [50];

	printf("\n");
	FILE* f = fopen(ADDRESSf, "r"); // открытие потока на чтение из f.txt
	FILE* g = fopen(ADDRESSg, "w"); // открытие потока на запись в g.txt

	if ((f != NULL) && (g != NULL)) { // если потоки открылись успешно

		int i, k, m, c = 0; // ПЕРЕМЕННЫЕ ДЛЯ ДОПа

		while (!feof(f)) { // пока f.txt не кончился
			fgets(STR, 50, f); // получение строки из f.txt
// если работа идет с готовым файлом, то строка, одновременно последняя и подходящая, игнорируется, поскольку достигается конец файла без символа новой строки
// решил проверкой на содержание символа новой строки в выделенной
			if ((strstr(STR, s) != NULL) && ((!feof(f)) || (strstr(STR, "\n") == NULL))) { // проверка на вхождение s в STR
				fputs(STR, g); // запись соответствующей STR В g.txt
			}

// ДОП ЗАДАНИЕ: СКОЛЬКО РАЗ ПОДСТРОКА ВХОДИТ В КАЖДУЮ ИЗ СТРОК ФАЙЛА
			if (!feof(f)) {
				c++;
				k = 0;
				m = 0;
				char* str = STR;
				while (strstr(str, s) != NULL) {
					k++;
					m = m + strlen(s);
					str = strstr(str, s) + m;
				}
				printf(" В строке %d фильтрующая встречается %d раз", c, k);
				printf("\n");
			}
// КОНЕЦ ДОП ЗАДАНИЯ

		}
		fclose(f); fclose(g); // закрытие потоков
		printf("\n");
	}
	else printf("Не удалось открыть файл(ы)"); // сообщение об ошибке
}

void outg(char* ADDRESSg) { // вывод конечного файла g.txt

	FILE* g = fopen(ADDRESSg, "r"); // открытие потока на чтение из g.txt
	char STR [50];
	while (!feof(g)) { // пока g.txt не кончился
		fgets(STR, 50, g); // получение строки из g.txt

		if ((!feof(g)) || (strstr(STR, "\n") == NULL)) puts(STR); // ее вывод

	}
	fclose(g); // закрытие потока
}

int main() {

	setlocale(LC_ALL, "rus");
	setlocale(LC_NUMERIC, "eng");

	char ADDRESSf[] = "C:\\Users\\asmis\\OneDrive\\Рабочий стол\\f9.txt";
	char ADDRESSg[] = "C:\\Users\\asmis\\OneDrive\\Рабочий стол\\g.txt";
	// def(ADDRESSf); // объявление и формирование исходного файла
	
	printf("\n Введи фильтрующую строку: ");
	char s[50]; gets_s(s, 50); // ввод строки-критерия для фильтрации

	work(ADDRESSf, ADDRESSg, s); // объявление и заполнение конечного файла
	printf(" Соответствующие строки, занесенные в файл g.text:\n\n"); outg(ADDRESSg); // вывод конечного файла

	return 0;
}

// + передача в функции
// + работа с готовым файлом невывод последней строки, в конце которой нет перевода на новую

// + сколько раз подстрока входит в каждую из строчек